
Page
1
of 14
Debugging with GDBBugs happen. Identifying and fixing them is part of the development process. There aremany different techniques for finding and characterizing program defects, including staticand dynamic analysis, code review, tracing, profiling, and interactive debugging. I will lookat tracers and profilers in the next chapter, but here I want to concentrate on the traditionalapproach of watching code execution through a debugger, which in our case is the GNUProject Debugger (GDB). GDB is a powerful and flexible tool. You can use it to debugapplications, examine the postmortem files (core files) that are created after a programcrash, and even step through kernel code.In this chapter, we will cover the following topics:The GNU debuggerPreparing to debugDebugging applicationsJust-in-time debuggingDebugging forks and threadsCore filesGDB user interfacesDebugging kernel codeThe GNU debuggerGDB is a source-level debugger for compiled languages, primarily C and C++, althoughthere is also support for a variety of other languages such as Go and Objective-C. Youshould read the notes for the version of GDB you are using to find out the current status ofsupport for the various languages.Debugging with GDB[ 357 ]The project website is http://www.gnu.org/software/gdb and it contains a lot of usefulinformation, including the GDB User Manual, Debugging with GDB.Out of the box, GDB has a command-line user interface, which some people find offputting,although in reality, it is easy to use with a little practice. If command-line interfacesare not to your liking, there are plenty of front-end user interfaces to GDB, and I willdescribe three of them later.Preparing to debugYou need to compile the code you want to debug with debug symbols. GCC offers twooptions for this: -g and -ggdb. The latter adds debug information that is specific to GDB,whereas the former generates information in an appropriate format for whichever targetoperating system you are using, making it the more portable option. In our particular case,
the target operating system is always Linux, and it makes little difference whether you use-  g or -ggdb. Of more interest is the fact that both options allow you to specify the level ofdebug information, from 0 to 3:0: This produces no debug information at all and is equivalent to omitting the -gor -ggdb switch1: This produces minimal information, but which includes function names andexternal variables, which is enough to generate a backtrace2: This is the default and includes information about local variables and linenumbers so that you can perform source-level debugging and single-step throughthe code3: This includes extra information which, among other things, means that GDBcan handle macro expansions correctlyIn most cases, -g suffices: reserve -g3 or -ggdb3 for if you are having problems steppingthrough code, especially if it contains macros.The next issue to consider is the level of code optimization. Compiler optimization tends todestroy the relationship between lines of source code and machine code, which makesstepping through the source unpredictable. If you experience problems like this, you willmost likely need to compile without optimization, leaving out the -O compile switch, orusing -Og, which enables optimizations that do not interfere with debugging.Debugging with GDB[ 358 ]A related issue is that of stack-frame pointers, which are needed by GDB to generate abacktrace of function calls up to the current one. On some architectures, GCC will notgenerate stack-frame pointers with the higher levels of optimization (-O2 and above). If youfind yourself in the situation that you really have to compile with -O2 but still wantbacktraces, you can override the default behavior with -fno-omit-frame-pointer. Alsolook out for code that has been hand-optimized to leave out frame pointers through theaddition of -fomit-frame-pointer: you may want to temporarily remove those bits.Debugging applicationsYou can use GDB to debug applications in one of two ways: if you are developing code torun on desktops and servers, or indeed any environment where you compile and run the
code on the same machine, it is natural to run GDB natively. However, most embeddeddevelopment is done using a cross toolchain, and hence you want to debug code running onthe device but control it from the cross-development environment, where you have thesource code and the tools. I will focus on the latter case since it is the most likely scenariofor embedded developers, but I will also show you how to set up a system for nativedebugging. I am not going to describe the basics of using GDB here since there are manygood references on that topic already, including the GDB user manual and the suggestedFurther reading at the end of the chapter.Remote debugging using gdbserverThe key component for remote debugging is the debug agent, gdbserver, which runs on thetarget and controls execution of the program being debugged. gdbserver connects to a copyof GDB running on the host machine via a network connection or a serial interface.Debugging through gdbserver is almost, but not quite, the same as debugging natively. Thedifferences are mostly centered around the fact that there are two computers involved andthey have to be in the right state for debugging to take place. Here are some things to lookout for:At the start of a debug session, you need to load the program you want to debugon the target using gdbserver, and then separately load GDB from your crosstoolchain on the host.GDB and gdbserver need to connect to each other before a debug session canbegin.GDB, running on the host, needs to be told where to look for debug symbols andsource code, especially for shared libraries.Debugging with GDB[ 359 ]The GDB run command does not work as expected.gdbserver will terminate when the debug session ends, and you will need torestart it if you want another debug session.You need debug symbols and source code for the binaries you want to debug onthe host, but not on the target. Often, there is not enough storage space for themon the target, and they will need to be stripped before deploying to the target.The GDB/gdbserver combination does not support all the features of nativelyrunning GDB: for example, gdbserver cannot follow the child process after a
fork, whereas native GDB can.Odd things can happen if GDB and gdbserver are of different versions, or are thesame version but configured differently. Ideally, they should be built from thesame source using your favorite build tool.Debug symbols increase the size of executables dramatically, sometimes by a factor of 10.As mentioned in Chapter 5, Building a Root Filesystem, it can be useful to remove debugsymbols without recompiling everything. The tool for the job is strip from your crosstoolchain. You can control the aggressiveness of strip with these switches:--strip-all: This removes all symbols (default)--strip-unneeded: This removes symbols not needed for relocation processing--strip-debug: This removes only debug symbolsFor applications and shared libraries, --strip-all (the default) is fine,but when it comes to kernel modules, you will find that it will stop themodule from loading. Use --strip-unneeded instead. I am still workingon a use case for âstrip-debug.With that in mind, let's look at the specifics involved in debugging with the Yocto Projectand Buildroot.Setting up the Yocto Project for remotedebuggingThere are two things to be done to debug applications remotely when using the YoctoProject: you need to add gdbserver to the target image, and you need to create an SDK thatincludes GDB and has debug symbols for the executables that you plan to debug.Debugging with GDB[ 360 ]First, then, to include gdbserver in the target image, you can add the package explicitly byadding this to conf/local.conf:IMAGE_INSTALL_append = " gdbserver"Alternatively, you can add tools-debug to EXTRA_IMAGE_FEATURES, which will addgdbserver, native gdb, and strace to the target image (I will talk about strace in the nextchapter):EXTRA_IMAGE_FEATURES = "debug-tweaks tools-debug"For the second part, you just need to build an SDK as I described in Chapter 6, Selecting aBuild System:$ bitbake -c populate_sdk <image>The SDK contains a copy of GDB. It also contains a sysroot for the target with debugsymbols for all the programs and libraries that are part of the target image. Finally, the SDK
contains the source code for the executables. For example, looking at an SDK built for theBeagleBone Black and generated by version 2.2.1 of the Yocto Project, it is installed bydefault into /opt/poky/2.2.1/. The sysroot for the target is/opt/poky/2.2.1/sysroots/cortexa8hf-neon-poky-linux-gnueabi/. Theprograms are in /bin/, /sbin/, /usr/bin/ and /usr/sbin/, relative to the sysroot, andthe libraries are in /lib/ and /usr/lib/. In each of these directories, you will find asubdirectory named .debug/ that contains the symbols for each program and library. GDBknows to look in .debug/ when searching for symbol information. The source code for theexecutables is stored in /usr/src/debug/, relative to the sysroot.Setting up Buildroot for remote debuggingBuildroot does not make a distinction between the build environment and that used forapplication development: there is no SDK. Assuming that you are using the Buildrootinternal toolchain, you need to enable these options to build the cross GDB for the host andto build gdbserver for the target:BR2_PACKAGE_HOST_GDB, in Toolchain | Build cross gdb for the hostBR2_PACKAGE_GDB, in Target packages | Debugging, profiling andbenchmark->gdbBR2_PACKAGE_GDB_SERVER, in Target packages | Debugging, profiling andbenchmark | gdbserverDebugging with GDB[ 361 ]You also need to build executables with debug symbols, for which you need to enableBR2_ENABLE_DEBUG, in Build options | build packages with debugging symbols.This will create libraries with debug symbols in output/host/usr/<arch>/sysroot.Starting to debugNow that you have gdbserver installed on the target and a cross GDB on the host, you canstart a debug session.Connecting GDB and gdbserverThe connection between GDB and gdbserver can be through a network or serial interface. Inthe case of a network connection, you launch gdbserver with the TCP port number to listenon and, optionally, an IP address to accept connections from. In most cases, you don't carewhich IP address is going to connect, so you can just provide the port number. In thisexample, gdbserver waits for a connection on port 10000 from any host:# gdbserver :10000 ./hello-worldProcess hello-world created; pid = 103Listening on port 10000
Next, start the copy of GDB from your toolchain, pointing it at an unstripped copy of theprogram so that GDB can load the symbol table:$ arm-poky-linux-gnueabi-gdb hello-worldIn GDB, use the command target remote to make the connection to gdbserver, giving itthe IP address or hostname of the target and the port it is waiting on:(gdb) target remote 192.168.1.101:10000When gdbserver sees the connection from the host, it prints the following:Remote debugging from host 192.168.1.1The procedure is similar for a serial connection. On the target, you tell gdbserver whichserial port to use:# gdbserver /dev/ttyO0 ./hello-worldDebugging with GDB[ 362 ]You may need to configure the port baud rate beforehand using stty(1) or a similarprogram. A simple example would be as follows:# stty -F /dev/ttyO0 115200There are many other options to stty, so read the manual page for more details. It isworthwhile noting that the port must not be being used for anything else. For example, youcan't use a port that is being used as the system console.On the host, you make the connection to gdbserver using target remote plus the serialdevice at the host end of the cable. In most cases, you will want to set the baud rate of thehost serial port first, using the GDB command set serial baud:(gdb) set serial baud 115200(gdb) target remote /dev/ttyUSB0Setting the sysrootGDB needs to know where to find debug information and source code for the program andshared libraries you are debugging. When debugging natively, the paths are well knownand built in to GDB, but when using a cross toolchain, GDB has no way to guess where theroot of the target filesystem is. You have to give it this information.If you built your application using the Yocto Project SDK, the sysroot is within the SDK,and so you can set it in GDB like this:(gdb) set sysroot /opt/poky/2.2.1/sysroots/cortexa8hf-neon-poky-linuxgnueabiIf you are using Buildroot, you will find that the sysroot is inoutput/host/usr/<toolchain>/sysroot, and that there is a symbolic link to it inoutput/staging. So, for Buildroot, you would set the sysroot like this:(gdb) set sysroot /home/chris/buildroot/output/stagingGDB also needs to find the source code for the files you are debugging. GDB has a searchpath for source files, which you can see using the command show directories:
(gdb) show directoriesSource directories searched: $cdir:$cwdDebugging with GDB[ 363 ]These are the defaults: $cwd is the current working directory of the GDB instance runningon the host; $cdir is the directory where the source was compiled. The latter is encodedinto the object files with the tag DW_AT_comp_dir. You can see these tags using objdump --  dwarf, like this, for example:$ arm-poky-linux-gnueabi-objdump --dwarf ./helloworld | grep DW_AT_comp_dir[...]<160> DW_AT_comp_dir : (indirect string, offset: 0x244):/home/chris/helloworld[...]In most cases, the defaults, $cdir:$cwd, are sufficient, but problems arise if the directorieshave been moved between compilation and debugging. One such case occurs with theYocto Project. Taking a deeper look at the DW_AT_comp_dir tags for a program compiledusing the Yocto Project SDK, you may notice this:$ arm-poky-linux-gnueabi-objdump --dwarf ./helloworld | grep DW_AT_comp_dir<2f> DW_AT_comp_dir : /usr/src/debug/glibc/2.24-r0/git/csu<79> DW_AT_comp_dir : (indirect string, offset: 0x139):/usr/src/debug/glibc/2.24-r0/git/csu<116> DW_AT_comp_dir : /usr/src/debug/glibc/2.24-r0/git/csu<160> DW_AT_comp_dir : (indirect string, offset: 0x244):/home/chris/helloworld[...]Here, you can see multiple references to the directory /usr/src/debug/glibc/2.24-r0/git, but where is it? The answer is that it is in the sysroot for the SDK, so the full pathis /opt/poky/2.2.1/sysroots/cortexa8hf-neon-poky-linuxgnueabi/usr/src/debug/glibc/2.24-r0/git. The SDK contains source code for all ofthe programs and libraries that are in the target image. GDB has a simple way to cope withan entire directory tree being moved like this: substitute-path. So, when debuggingwith the Yocto Project SDK, you need to use these commands:(gdb) set sysroot /opt/poky/2.2.1/sysroots/cortexa8hf-neon-poky-linuxgnueabi(gdb) set substitute-path /usr/src/debug/opt/poky/2.2.1/sysroots/cortexa8hf-neon-poky-linux-gnueabi/usr/src/debugYou may have additional shared libraries that are stored outside the sysroot. In that case,you can use set solib-search-path, which can contain a colon-separated list ofdirectories to search for shared libraries. GDB searches solib-search-path only if it
cannot find the binary in the sysroot.Debugging with GDB[ 364 ]A third way of telling GDB where to look for source code, for both libraries and programs,is using the directory command:(gdb) directory /home/chris/MELP/src/lib_mylibSource directories searched: /home/chris/MELP/src/lib_mylib:$cdir:$cwdPaths added in this way take precedence because they are searched before those fromsysroot or solib-search-path.GDB command filesThere are some things that you need to do each time you run GDB, for example, setting thesysroot. It is convenient to put such commands into a command file and run them eachtime GDB is started. GDB reads commands from $HOME/.gdbinit, then from .gdbinit inthe current directory, and then from files specified on the command line with the -xparameter. However, recent versions of GDB will refuse to load .gdbinit from the currentdirectory for security reasons. You can override that behavior for by adding a line like thisto your $HOME/.gdbinit:set auto-load safe-path /Alternatively, if you don't want to enable auto-loading globally, you can specify a particulardirectory like this:add-auto-load-safe-path /home/chris/myprogMy personal preference is to use the -x parameter to point to the command file, whichexposes the location of the file so that I don't forget about it.To help you set up GDB, Buildroot creates a GDB command file containing the correctsysroot command in output/staging/usr/share/buildroot/gdbinit. It will containa line similar to this one:set sysroot /home/chris/buildroot/output/host/usr/arm-buildroot-linuxgnueabi/sysrootDebugging with GDB[ 365 ]Overview of GDB commandsGDB has a great many commands, which are described in the online manual and in theresources mentioned in the Further reading section. To help you get going as quickly aspossible, here is a list of the most commonly used commands. In most cases there, is a shortform for the command, which is listed in the tables following.BreakpointsThese are the commands for managing breakpoints:Command Short-form command Use
break <location> b <location> Set a breakpoint on a function name, linenumber, or line. Examples of locationsare main, 5, and sortbug.c:42.info breakpoints i b List breakpoints.delete breakpoint<N>d b <N> Delete breakpoint <N>.Running and steppingThese are commands for controlling the execution of a program:Command Short-formcommandUserun r Load a fresh copy of the program into memory and startrunning it. This does not work for remote debug using gdbserver.continue c Continue execution from a breakpoint.Ctrl-C - Stop the program being debugged.step s Step one line of code, stepping into any function that is called.next n Step one line of code, stepping over a function call.finish - Run until the current function returns.Debugging with GDB[ 366 ]Getting informationThese are commands for getting information about the debugger:Command Short-formcommandUsebacktrace bt List the call stackinfo threads i th Display information about the threadsexecuting in the programinfo sharedlibrary i share Display information about shared librariescurrently loaded by the programprint <variable> p <variable> Print the value of a variable, for exampleprint foolist l List lines of code around the current programcounterRunning to a breakpointGdbserver loads the program into memory and sets a breakpoint at the first instruction,then waits for a connection from GDB. When the connection is made, you enter into adebug session. However, you will find that if you try to single-step immediately, you willget this message:Cannot find bounds of current functionThis is because the program has been halted in code written in assembly which creates theruntime environment for C and C++ programs. The first line of C or C++ code is the main()function. Supposing that you want to stop at main(), you would set a breakpoint there andthen use the continue command (abbreviation c) to tell gdbserver to continue from thebreakpoint at the start of the program and stop at main():(gdb) break main
Breakpoint 1, main (argc=1, argv=0xbefffe24) at helloworld.c:8printf("Hello, world!\n");(gdb) cAt this point, you may see the following:Reading /lib/ld-linux.so.3 from remote target...warning: File transfers from remote targets can be slow. Use "set sysroot"to access files locally instead.Debugging with GDB[ 367 ]With older versions of GDB, you may instead see this:warning: Could not load shared library symbols for 2 libraries, e.g./lib/libc.so.6.In both cases, the problem is that you have forgotten to set the sysroot! Take another lookat the earlier section on sysroot.This is all very different to starting a program natively, where you just type run. In fact, ifyou try typing run in a remote debug session, you will either see a message saying that theremote target does not support the run command, or in older versions of GDB, it will justhang without any explanation.Native debuggingRunning a native copy of GDB on the target is not as common as doing it remotely, but it ispossible. As well as installing GDB in the target image, you will also need unstripped copiesof the executables you want to debug and the corresponding source code installed in thetarget image. Both the Yocto Project and Buildroot allow you to do this.While native debugging is not a common activity for embeddeddevelopers, running profile and trace tools on the target is very common.These tools usually work best if you have unstripped binaries and sourcecode on the target, which is half of the story I am telling here. I will returnto the topic in the next chapter.The Yocto ProjectTo begin with, you need to add gdb to the target image by adding this toconf/local.conf:IMAGE_INSTALL_append = " gdb"Next, you need the debug information for the packages you want to debug. The YoctoProject builds debug variants of packages, which contain unstripped binaries and thesource code. You can add these debug packages selectively to your target image by adding<package name>-dbg to your conf/local.conf. Alternatively, you can simply install alldebug packages by adding dbg-pkgs to EXTRA_IMAGE_FEATURES. Be warned that this willincrease the size of the target image dramatically, perhaps by several hundreds ofmegabytes.EXTRA_IMAGE_FEATURES = "dbg-pkgs"
Debugging with GDB[ 368 ]The source code is installed into /usr/src/debug/<package name> in the target image.This means that GDB will pick it up without needing to run set substitute-path. If youdon't need the source, you can prevent it from being installed by adding this to yourconf/local.conf file:PACKAGE_DEBUG_SPLIT_STYLE = "debug-without-src"BuildrootWith Buildroot, you can tell it to install a native copy of GDB in the target image byenabling this option:BR2_PACKAGE_GDB_DEBUGGER in Target packages | Debugging, profiling andbenchmark | Full debuggerThen, to build binaries with debug information and to install them in the target imagewithout stripping, enable these two options:BR2_ENABLE_DEBUG in Build options | Build packages with debuggingsymbolsBR2_STRIP_none in Build options | Strip command for binaries on targetJust-in-time debuggingSometimes a program will start to misbehave after it has been running for a while, and youwould like to know what it is doing. The GDB attach feature does exactly this. I call it justin-time debugging. It is available with both native and remote debug sessions.In the case of remote debugging, you need to find the PID of the process to be debuggedand pass it to gdbserver with the --attach option. For example, if the PID is 109, youwould type this:# gdbserver --attach :10000 109Attached; pid = 109Listening on port 10000Debugging with GDB[ 369 ]This forces the process to stop as if it were at a breakpoint, allowing you to start your crossGDB in the normal way and connect to gdbserver. When you are done, you can detach,allowing the program to continue running without the debugger:(gdb) detachDetaching from program: /home/chris/MELP/helloworld/helloworld, process 109Ending remote debugging.Debugging forks and threadsWhat happens when the program you are debugging forks? Does the debug session followthe parent process or the child? This behavior is controlled by follow-fork-mode, which
may be parent or child, with parent being the default. Unfortunately, current versions ofgdbserver do not support this option, so it only works for native debugging. If you reallyneed to debug the child process while using gdbserver, a workaround is to modify the codeso that the child loops on a variable immediately after the fork, giving you the opportunityto attach a new gdbserver session to it and then to set the variable so that it drops out of theloop.When a thread in a multi-threaded process hits a breakpoint, the default behavior is for allthreads to halt. In most cases, this is the best thing to do as it allows you to look at staticvariables without them being changed by the other threads. When you recommenceexecution of the thread, all the stopped threads start up, even if you are single-stepping,and it is especially this last case that can cause problems. There is a way to modify the wayin which GDB handles stopped threads, through a parameter called scheduler-locking.Normally it is off, but if you set it to on, only the thread that was stopped at the breakpointis resumed and the others remain stopped, giving you a chance to see what the thread alonedoes without interference. This continues to be the case until you turn schedulerlockingoff. Gdbserver supports this feature.Core filesCore files capture the state of a failing program at the point that it terminates. You don'teven have to be in the room with a debugger when the bug manifests itself. So, when yousee Segmentation fault (core dumped), don't shrug; investigate the core file andextract the goldmine of information in there.Debugging with GDB[ 370 ]The first observation is that core files are not created by default, but only when the core fileresource limit for the process is non-zero. You can change it for the current shell usingulimit -c. To remove all limits on the size of core files, type the following command:$ ulimit -c unlimitedBy default, the core file is named core and is placed in the current working directory of theprocess, which is the one pointed to by /proc/<PID>/cwd. There are a number of problemswith this scheme. Firstly, when looking at a device with several files named core, it is not
obvious which program generated each one. Secondly, the current working directory of theprocess may well be in a read-only filesystem, there may not be enough space to store thecore file, or the process may not have permissions to write to the current working directory.There are two files that control the naming and placement of core files. The first is/proc/sys/kernel/core_uses_pid. Writing a 1 to it causes the PID number of the dyingprocess to be appended to the filename, which is somewhat useful as long as you canassociate the PID number with a program name from log files.Much more useful is /proc/sys/kernel/core_pattern, which gives you a lot morecontrol over core files. The default pattern is core, but you can change it to a patterncomposed of these meta characters:%p: The PID%u: The real UID of the dumped process%g: The real GID of the dumped process%s: The number of the signal causing the dump%t: The time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00+0000 (UTC)%h: The hostname%e: The executable filename%E: The path name of the executable, with slashes (/) replaced by exclamationmarks (!)%c: The core file size soft resource limit of the dumped processYou can also use a pattern that begins with an absolute directory name so that all core filesare gathered together in one place. As an example, the following pattern puts all core filesinto the directory /corefiles and names them with the program name and the time of thecrash:# echo /corefiles/core.%e.%t > /proc/sys/kernel/core_patternDebugging with GDB[ 371 ]Following a core dump, you would find something like this:# ls /corefilescore.sort-debug.1431425613For more information, refer to the manual page core(5).Using GDB to look at core filesHere is a sample GDB session looking at a core file:$ arm-poky-linux-gnueabi-gdb sort-debug/home/chris/rootfs/corefiles/core.sort-debug.1431425613[...]Core was generated by `./sort-debug'.Program terminated with signal SIGSEGV, Segmentation fault.#0 0x000085c8 in addtree (p=0x0, w=0xbeac4c60 "the") at sort-debug.c:4141 p->word = strdup (w);
That shows that the program stopped at line 41. The list command shows the code in thevicinity:(gdb) list37 static struct tnode *addtree (struct tnode *p, char *w)38 {39 int cond;4041 p->word = strdup (w);42 p->count = 1;43 p->left = NULL;44 p->right = NULL;45The backtrace command (shortened to bt) shows how we got to this point:(gdb) bt#0 0x000085c8 in addtree (p=0x0, w=0xbeac4c60 "the") at sort-debug.c:41#1 0x00008798 in main (argc=1, argv=0xbeac4e24) at sort-debug.c:89An obvious mistake: addtree() was called with a null pointer.Debugging with GDB[ 372 ]GDB user interfacesGDB is controlled at a low level through the GDB machine interface, GDB/MI, which can beused to wrap GDB in a user interface or as part of a larger program, and it considerablyextends the range of options available to you.In this section, I will describe three that are well suited to debugging embedded targets: theTerminal user interface, TUI; the data display debugger, DDD; and the Eclipse CdevelopmentToolkit (CDT).
